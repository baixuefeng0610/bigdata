help setbit可以查看setbit的命令
redis-cli --raw 会根据当前xshell的字符集编码来显示

yum -install nc  然后可以直接连接redis  nc localhost 6379
redis的事务：有开启事务，执行事务，在事务中还有一个是监控事务watch，当在开启事务前，先开启watch key,当另一个客户端将监控的值发生修改，则当前客户端在开启事务后做的关于刚才监控的那个key的所有操作将会被
取消。
redis布隆过滤器：解决缓存穿透问题。当redis作为缓存中间件，由于redis没有缓存一些数据，但是这些数据正好是用户请求的数据，这时候用户请求就会绕过redis直达关系型数据库，但是，其实数据库中也没有这些数据，
这样数据库会做很多无用的工作，导致真正有需求的无法访问。布隆过滤器就是用小的空间解决大量和关系型数据库匹配数据的问题。

布隆过滤器工作原理：通过将数据库有的数据通过哈希映射函数计算出的值，在bitmap中二进制位标记，比如该商品进行一次哈希运算，得出数值为3，则在二进制位3的位置标记为1，以此类推
进行第二次哈希运算，依旧标记二进制位。当有客户端请求某个元素，也是先进行哈希映射函数，只有该元素计算出的位置，有一位标记的为0，则表示该元素在数据库中不存在。


redis发布和订阅：
在一个reids客户端创建订阅渠道：SUBSCRIBE redisChat
然后另外开启一个redis客户端： PUBLISH redisChat "Redis is a great caching technique"
此时第一个客户端就会收到第二个客户端推送的消息。


redis watch命令监控事务：
在 Redis 中使用 watch 命令可以决定事务是执行还是回滚。可以在 multi 命令之前使用 watch 命令监控某些键值对，然后使用 multi 命令开启事务，执行各类对数据结构进行操作的命令，这个时候这些命令就会进入队列。
当 Redis 使用 exec 命令执行事务的时候，它首先会去比对被 watch 命令所监控的键值对，如果没有发生变化，那么它会执行事务队列中的命令，提交事务；如果发生变化，那么它不会执行任何事务中的命令，
而去事务回滚。无论事务是否回滚，Redis 都会去取消执行事务前的 watch 命令，


表 2 事务检测
时刻	客户端	说   明
T1	set key1 value1	初始化key1
T2	watch key1	监控 key1 的键值对
T3	multi	开启事务
T4	set key2 value2	设置 key2 的值
T5	exec	提交事务，Redis 会在这个时间点检测 key1 的值在 T2 时刻后，有没有被其他命令修改过，如果没有，则提交事务去执行

Redis 在执行事务的过程中，并不会阻塞其他连接的并发，而只是通过比较 watch 监控的键值对去保证数据的一致性，所以 Redis 多个事务完全可以在非阻塞的多线程环境中并发执行，
而且 Redis 的机制是不会产生 ABA 问题的，这样就有利于在保证数据一致的基础上，提高高并发系统的数据读/写性能。


redis key的删除策略：
redis 过期策略是：定期删除+惰性删除。
定期删除：所谓定期删除，指的是 redis 默认是每隔 100ms 就随机抽取一些设置了过期时间的 key，检查其是否过期，如果过期就删除。
假设 redis 里放了 10w 个 key，都设置了过期时间，你每隔几百毫秒，就检查 10w 个 key，那 redis 基本上就死了，cpu 负载会很高的，
消耗在你的检查过期 key 上了。注意，这里可不是每隔 100ms 就遍历所有的设置过期时间的 key，那样就是一场性能上的灾难。实际上 redis 是每隔 100ms 随机抽取一些 key 来检查和删除的。
定期删除可能会导致很多key到了过期时间，却没有进行删除。此时内存会堆积大量过期的key。

惰性删除：内存淘汰机制
• noeviction: 当内存不足以容纳新写入数据时，新写入操作会报错，这个一般没人用吧，实在是太恶心了。
• allkeys-lru：当内存不足以容纳新写入数据时，在键空间中，移除最近最少使用的 key（这个是最常用的）。
• allkeys-random：当内存不足以容纳新写入数据时，在键空间中，随机移除某个 key，这个一般没人用吧，为啥要随机，肯定是把最近最少使用的 key 给干掉啊。
• volatile-lru：当内存不足以容纳新写入数据时，在设置了过期时间的键空间中，移除最近最少使用的 key（这个一般不太合适）。
• volatile-random：当内存不足以容纳新写入数据时，在设置了过期时间的键空间中，随机移除某个 key。
• volatile-ttl：当内存不足以容纳新写入数据时，在设置了过期时间的键空间中，有更早过期时间的 key 优先移除。

redis的key的过期时间：
   1、当key设置了过期时间，即使有客户端在访问这个key，这个key在达到设置的过期时间后，直接删除key
   2、当key设置过期时间，在有效期内，该key的值被修改过，这key的过期时间会被移除。

redis的持久化：
   1、RDB方式：RDB分为save、bgsave，其中save常用于关机维护，bgsave则是既可以提供服务，同时又可以持久化，通过fork一个子进程来进行持久化数据，会在指定目录生成一个X.dump文件，此文件为一个二进制快照文件。
      优点：恢复数据快
      弊端：只有一个dump文件、丢失数据相对较多，时点与时点之间窗口数据容易丢失比如8点一个dump文件，到9点刚要开始执行，此时挂机了
   2、AOF方式：redis写操作命令到文件中，如果在redis中同时开启了RDB和AOF，此时只会使用AOF进行恢复。在redis4.0后AOF文件既包含RDB全量，同时还有增加新记录写的操作命令。
      弊端：文件无限变大，恢复慢。


4.0后使用的RDB全量+AOF新增记录的混合方式类似于hdfs的fsimage+edits log，让日志只记录增量，然后合并。
4.0前的redis的AOF有一个重写过程，会将删除以及一些修改命令抵消，合并重复命令，最终是一个纯指令文件，在4.0后的重写过程将旧的的数据使用RDB方式存储，然后新增的通过AOF方式。


redis单机、单节点、单实例
单点故障、容量有限、压力


集群是奇数台：必须要过半N/2+1 ；
因为使用三台，其中一个节点挂掉，2台过半可以投票，使用4台，当一个节点挂掉后，需要三台正常才能过半，相对于成本来说，4台和3台效果是一样的，3台和4台所承担的风险是一样的，只允许一台挂掉，
不论3台还是4台如果两台挂掉，就无法过半做出决策。所以一般选奇数台作为一个集群的节点个数。


redis使用默认的异步复制、特点是低延迟、高性能


redis哨兵模式：开发者通过连接哨兵进行读取或者写数据，哨兵对redis主节点进行监控，当一个主挂掉，哨兵监控，然后通过投票切换另一个主节点，哨兵模式采用的是主从复制模式，所以每个节点的数据是一致的。
主从节点通过异步同步数据的方式进行节点间的数据同步，第一种是通过数据落地磁盘在通过网路同步过去，或者直接通过网络同步过去，而且哨兵模式不是绝对的实时同步，可能会造成一部分数据丢失。
redis集群模式：集群模式，数据采用分片方式存储，数据分散在不同的节点存储。